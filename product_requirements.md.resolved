# LiveLens Backend Product Requirements Document (PRD)

Based on our current database schema (`Users`, `Venues`, `Events`, `Seats`, `Reviews`, `SeatAggregates`, `AI_Predictions`, `SimilarSeats`), here is a comprehensive breakdown of the core features we need to build, structured logically for your team members.

---

## 1. üìù Review Submission Flow (JWT Protected)
**Goal:** Allow logged-in users to review a specific seat at a specific event.

### What is already known (Do NOT ask user to type):
- **`user_id`**: Extracted securely from their JWT login token.
- **`venue_id`**: Inferred automatically from the `event_id` they selected.
- **`seat_id`**: If the user selects a Section/Row/Seat on the UI frontend, the backend should query the `Seats` table to find the UUID. The user shouldn't type a UUID.

### What the user *must* provide (The Request Payload):
- `event_id`: Which concert did they go to? (Selected from a dropdown/UI)
- `section`, `row`, `seat_number`: Exactly where they sat.
- `text`: Their written review.
- Optional: `rating_visual`, `rating_sound`, `rating_value`, `overall_rating` (1-5 scales).
- Optional: `price_paid`.
- Optional: `images` (List of S3 image URLs).

### Backend Logic Needed (Ticket: #API-Review-Create):
1. **Verify Auth:** Reject if JWT is invalid.
2. **Find/Create Seat:** The API receives [(section, row, seat_number, venue_id)](file:///c:/MyCodes/LiveLens/Backend/api/routes/auth.py#64-101). It checks the `Seats` table. If the seat exists, get its UUID. If not, **create it** in the `Seats` table. (Or, ideally, the frontend provides the predefined `seat_id` that was already loaded from the Venue Map).
3. **Insert Review:** Save the review into the `Reviews` table.
4. **Trigger Aggregation Update:** After saving, immediately launch an async background task to update `SeatAggregates` for that specific seat.

---

## 2. üèõÔ∏è Venue & Seat Spatial Data (Data Engineering Pipeline)
**Goal:** Define the physical layout of arenas (like Scotiabank Arena).

### How do we get `x, y, z, orientation, distance_to_stage` for Seats?
You completely hit the nail on the head: **Users CANNOT provide this.** This is pure spatial data that belongs strictly to the Venue map.
- **Implementation Strategy:** Let's create a *Bootstrap Script* (run once per venue). An admin uploads a JSON/GeoJSON mapping of Scotiabank arena describing polygons and section coordinates.
- **Ticket: #Data-Venue-Mapper:** A Python script that pre-populates the `Seats` table for Scotiabank Arena with calculated `distance_to_stage` scores so the Review API doesn't have to calculate things on the fly.

---

## 3. üìä Seat Aggregation & Pre-processing (Cron/Async)
**Goal:** Ensure extremely fast reads for the frontend. We cannot run `AVG()` across 1 million reviews every time someone searches for seats.

### How it works:
- Every time a new review is submitted, it updates `SeatAggregates`.
- **Ticket: #Data-Aggregator-Task:** Write a Python function (FastAPI BackgroundTask or Celery) that runs a native SQL upsert:
  ```sql
  INSERT INTO SeatAggregates (seat_id, avg_visual, review_count, last_updated)
  SELECT seat_id, AVG(rating_visual), COUNT(id), NOW()
  FROM Reviews WHERE seat_id = :target_seat
  ON CONFLICT (seat_id) DO UPDATE SET ...
  ```

---

## 4. üß† Text-to-IDF & AI Integration
**Goal:** Turn unstructured review text into searchable insights, scores, and SimilarSeat mapping.

### The Pipeline:
1. User submits text: *"Audio was terrible, massive echo, but I could see Taylor Swift perfectly."*
2. **Ticket: #AI-NLP-Worker:** A background worker reads new reviews, strips stop words, extracts NLP keywords (e.g., `['echo', 'bad sound', 'great view']`), and computes TF-IDF scores (if utilizing an internal search engine like ElasticSearch, or just dumping keywords into JSONB tags).
3. **Ticket: #AI-Prediction-Engine:** Send the batch of text to an LLM (OpenAI/Gemini/Bedrock) asking to score the seat's acoustics and visual quality based on the text. Save the result in the `AI_Predictions` table.
4. **Ticket: #Data-Similarity-Engine (ML):** Use the `SimilarSeats` table. An offline Machine Learning script runs nightly, clustering seats based on their `distance_to_stage`, `x`, `y`, `price_paid`, and NLP tags using K-Means or Cosine Similarity, updating the similarity scores so users can find alternative tickets if their desired seat is sold out.

---

## 5. üîç Core Search & Recommendation API
**Goal:** Support complex user queries from the frontend app without lagging the database.

### Ticket: #API-Search-Top10
- **Use Case:** "Show me the top 10 seats for the upcoming Taylor Swift concert ranked by best Visuals."
- **API Logic:** Fast `JOIN`.
  ```sql
  SELECT s.section, s.row, s.seat_number, a.avg_visual 
  FROM Seats s 
  JOIN SeatAggregates a ON s.id = a.seat_id
  WHERE s.venue_id = 'xxx'
  ORDER BY a.avg_visual DESC LIMIT 10;
  ```

### Ticket: #API-Search-Similar
- **Use Case:** "The seat I clicked is sold out. Show me similar experiences."
- **API Logic:** Fast lookup in `SimilarSeats` table. Output the top 5 `similar_seat_id` rows sorted by `similarity_score DESC`.

---

## Summary of Upcoming Team Assignments üõ†Ô∏è

If you are assigning tickets to your team tomorrow, here is the exact priority list:

1. **[Backend/API - High] `POST /reviews`**: Build the JWT-authenticated API to cleanly accept a Review payload and safely `INSERT` into the DB.
2. **[Backend/Data - High] `worker_aggregation.py`**: Write the raw SQL trigger/background task to calculate `SeatAggregates` when reviews are added.
3. **[Backend/API - Medium] `GET /venues/{id}/top-seats`**: Build the search endpoint that queries `SeatAggregates` and returns lists of top-rated seats for the UI map.
4. **[Data Import - Medium] `import_scotiabank.py`**: A one-time admin script to ingest Scotiabank Arena's `x,y,z` coordinates into the `Seats` table.
5. **[Backend/AI - Low/Phase 3] `worker_nlp.py`**: Hook up an LLM API to process review `text` periodically and populate the `AI_Predictions` and `SimilarSeats` tables.
